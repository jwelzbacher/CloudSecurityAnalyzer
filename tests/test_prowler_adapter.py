"""Tests for Prowler adapter."""

import tempfile
from pathlib import Path
from unittest.mock import AsyncMock, patch

import pytest

from cs_kit.adapters.prowler.exceptions import (
    ProwlerError,
    ProwlerNotFoundError,
)
from cs_kit.adapters.prowler.run import (
    _build_prowler_command,
    _parse_compliance_list,
    list_supported_frameworks,
    run_prowler,
    validate_prowler_installation,
)


class TestRunProwler:
    """Test run_prowler function."""

    @pytest.mark.asyncio
    async def test_prowler_not_found(self) -> None:
        """Test error when prowler is not found."""
        with patch("shutil.which", return_value=None):
            with pytest.raises(ProwlerNotFoundError) as exc_info:
                await run_prowler(
                    provider="aws",
                    frameworks=["cis_aws_1_4"],
                    regions=["us-east-1"],
                    env={},
                    out_dir=Path("/tmp"),
                )

            assert "prowler not found on PATH" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_successful_aws_run(self) -> None:
        """Test successful AWS prowler run."""
        with tempfile.TemporaryDirectory() as tmp_dir:
            out_dir = Path(tmp_dir)

            # Mock prowler being available
            with patch("shutil.which", return_value="/usr/bin/prowler"):
                # Mock successful subprocess execution
                mock_process = AsyncMock()
                mock_process.returncode = 0
                mock_process.communicate.return_value = (b"success", b"")

                with patch("asyncio.create_subprocess_exec", return_value=mock_process):
                    # Create a mock JSON file that would be generated by prowler
                    provider_dir = out_dir / "scanner=prowler" / "provider=aws"
                    provider_dir.mkdir(parents=True)
                    json_file = provider_dir / "results-123.json"
                    json_file.write_text('{"test": "data"}')

                    result = await run_prowler(
                        provider="aws",
                        frameworks=["cis_aws_1_4"],
                        regions=["us-east-1"],
                        env={"AWS_PROFILE": "test"},
                        out_dir=out_dir,
                    )

                    assert len(result) == 1
                    assert result[0] == json_file
                    assert result[0].exists()

    @pytest.mark.asyncio
    async def test_prowler_execution_failure(self) -> None:
        """Test prowler execution failure."""
        with tempfile.TemporaryDirectory() as tmp_dir:
            out_dir = Path(tmp_dir)

            with patch("shutil.which", return_value="/usr/bin/prowler"):
                # Mock failed subprocess execution
                mock_process = AsyncMock()
                mock_process.returncode = 1
                mock_process.communicate.return_value = (b"", b"error message")

                with patch("asyncio.create_subprocess_exec", return_value=mock_process):
                    with pytest.raises(ProwlerError) as exc_info:
                        await run_prowler(
                            provider="aws",
                            frameworks=[],
                            regions=[],
                            env={},
                            out_dir=out_dir,
                        )

                    assert "Prowler execution failed" in str(exc_info.value)
                    assert "return code 1" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_no_json_output_generated(self) -> None:
        """Test error when no JSON files are generated."""
        with tempfile.TemporaryDirectory() as tmp_dir:
            out_dir = Path(tmp_dir)

            with patch("shutil.which", return_value="/usr/bin/prowler"):
                # Mock successful subprocess but no files generated
                mock_process = AsyncMock()
                mock_process.returncode = 0
                mock_process.communicate.return_value = (b"success", b"")

                with patch("asyncio.create_subprocess_exec", return_value=mock_process):
                    with pytest.raises(ProwlerError) as exc_info:
                        await run_prowler(
                            provider="gcp",
                            frameworks=[],
                            regions=[],
                            env={},
                            out_dir=out_dir,
                        )

                    assert "No JSON output files found" in str(exc_info.value)

    @pytest.mark.asyncio
    @pytest.mark.parametrize("provider", ["aws", "gcp", "azure"])
    async def test_all_providers(self, provider: str) -> None:
        """Test all supported providers."""
        with tempfile.TemporaryDirectory() as tmp_dir:
            out_dir = Path(tmp_dir)

            with patch("shutil.which", return_value="/usr/bin/prowler"):
                mock_process = AsyncMock()
                mock_process.returncode = 0
                mock_process.communicate.return_value = (b"success", b"")

                with patch("asyncio.create_subprocess_exec", return_value=mock_process):
                    # Create expected output file
                    provider_dir = out_dir / "scanner=prowler" / f"provider={provider}"
                    provider_dir.mkdir(parents=True)
                    json_file = provider_dir / "results.json"
                    json_file.write_text('{"test": "data"}')

                    result = await run_prowler(
                        provider=provider,  # type: ignore
                        frameworks=[],
                        regions=[],
                        env={},
                        out_dir=out_dir,
                    )

                    assert len(result) == 1
                    assert result[0].exists()


class TestBuildProwlerCommand:
    """Test _build_prowler_command function."""

    def test_aws_basic_command(self) -> None:
        """Test basic AWS command building."""
        cmd = _build_prowler_command(
            provider="aws",
            frameworks=[],
            regions=[],
            out_dir=Path("/tmp/output"),
        )

        expected = ["prowler", "aws", "-M", "json-ocsf", "-o", "/tmp/output"]
        assert cmd == expected

    def test_aws_with_regions_and_frameworks(self) -> None:
        """Test AWS command with regions and frameworks."""
        cmd = _build_prowler_command(
            provider="aws",
            frameworks=["cis_aws_1_4", "nist_csf"],
            regions=["us-east-1", "us-west-2"],
            out_dir=Path("/tmp/output"),
        )

        expected = [
            "prowler", "aws", "-M", "json-ocsf", "-o", "/tmp/output",
            "-f", "us-east-1,us-west-2",
            "--compliance", "cis_aws_1_4,nist_csf"
        ]
        assert cmd == expected

    def test_gcp_command(self) -> None:
        """Test GCP command building."""
        cmd = _build_prowler_command(
            provider="gcp",
            frameworks=["cis_gcp_1_3"],
            regions=[],  # GCP doesn't use regions in the same way
            out_dir=Path("/tmp/output"),
        )

        expected = [
            "prowler", "gcp", "-M", "json-ocsf", "-o", "/tmp/output",
            "--compliance", "cis_gcp_1_3"
        ]
        assert cmd == expected

    def test_azure_command(self) -> None:
        """Test Azure command building."""
        cmd = _build_prowler_command(
            provider="azure",
            frameworks=["cis_azure_1_4"],
            regions=[],  # Azure doesn't use regions parameter
            out_dir=Path("/tmp/output"),
        )

        expected = [
            "prowler", "azure", "-M", "json-ocsf", "-o", "/tmp/output",
            "--compliance", "cis_azure_1_4"
        ]
        assert cmd == expected

    @pytest.mark.parametrize("provider", ["aws", "gcp", "azure"])
    def test_all_providers_basic(self, provider: str) -> None:
        """Test basic command building for all providers."""
        cmd = _build_prowler_command(
            provider=provider,  # type: ignore
            frameworks=[],
            regions=[],
            out_dir=Path("/tmp/output"),
        )

        assert cmd[0] == "prowler"
        assert cmd[1] == provider
        assert "-M" in cmd
        assert "json-ocsf" in cmd
        assert "-o" in cmd
        assert "/tmp/output" in cmd


class TestListSupportedFrameworks:
    """Test list_supported_frameworks function."""

    @pytest.mark.asyncio
    async def test_prowler_not_found(self) -> None:
        """Test error when prowler is not found."""
        with patch("shutil.which", return_value=None):
            with pytest.raises(ProwlerNotFoundError):
                await list_supported_frameworks()

    @pytest.mark.asyncio
    async def test_successful_list(self) -> None:
        """Test successful framework listing."""
        mock_output = """Available compliance frameworks:
---
cis_aws_1_4: CIS Amazon Web Services Foundations Benchmark v1.4
cis_gcp_1_3: CIS Google Cloud Platform Foundation Benchmark v1.3
nist_csf: NIST Cybersecurity Framework
"""

        with patch("shutil.which", return_value="/usr/bin/prowler"):
            mock_process = AsyncMock()
            mock_process.returncode = 0
            mock_process.communicate.return_value = (mock_output.encode(), b"")

            with patch("asyncio.create_subprocess_exec", return_value=mock_process):
                frameworks = await list_supported_frameworks()

                expected = ["cis_aws_1_4", "cis_gcp_1_3", "nist_csf"]
                assert frameworks == expected

    @pytest.mark.asyncio
    async def test_prowler_execution_failure(self) -> None:
        """Test prowler execution failure."""
        with patch("shutil.which", return_value="/usr/bin/prowler"):
            mock_process = AsyncMock()
            mock_process.returncode = 1
            mock_process.communicate.return_value = (b"", b"error")

            with patch("asyncio.create_subprocess_exec", return_value=mock_process):
                with pytest.raises(ProwlerError) as exc_info:
                    await list_supported_frameworks()

                assert "Failed to list compliance frameworks" in str(exc_info.value)


class TestParseComplianceList:
    """Test _parse_compliance_list function."""

    def test_parse_typical_output(self) -> None:
        """Test parsing typical prowler compliance list output."""
        output = """Available compliance frameworks:
---
cis_aws_1_4: CIS Amazon Web Services Foundations Benchmark v1.4
cis_gcp_1_3: CIS Google Cloud Platform Foundation Benchmark v1.3
nist_csf: NIST Cybersecurity Framework
soc2: SOC 2 Type II
"""

        frameworks = _parse_compliance_list(output)
        expected = ["cis_aws_1_4", "cis_gcp_1_3", "nist_csf", "soc2"]
        assert frameworks == expected

    def test_parse_empty_output(self) -> None:
        """Test parsing empty output."""
        frameworks = _parse_compliance_list("")
        assert frameworks == []

    def test_parse_no_frameworks(self) -> None:
        """Test parsing output with no frameworks."""
        output = """Available compliance frameworks:
---
No frameworks available.
"""
        frameworks = _parse_compliance_list(output)
        assert frameworks == []

    def test_parse_malformed_lines(self) -> None:
        """Test parsing output with malformed lines."""
        output = """Available compliance frameworks:
---
cis_aws_1_4: CIS Amazon Web Services Foundations Benchmark v1.4
malformed_line_without_colon
: empty_framework_id
valid_framework: Description
"""
        frameworks = _parse_compliance_list(output)
        expected = ["cis_aws_1_4", "valid_framework"]
        assert frameworks == expected


class TestValidateProwlerInstallation:
    """Test validate_prowler_installation function."""

    @pytest.mark.asyncio
    async def test_prowler_not_found(self) -> None:
        """Test validation when prowler is not found."""
        with patch("shutil.which", return_value=None):
            with pytest.raises(ProwlerNotFoundError):
                await validate_prowler_installation()

    @pytest.mark.asyncio
    async def test_successful_validation(self) -> None:
        """Test successful prowler validation."""
        with patch("shutil.which", return_value="/usr/local/bin/prowler"):
            mock_process = AsyncMock()
            mock_process.returncode = 0
            mock_process.communicate.return_value = (b"prowler 3.5.0", b"")

            with patch("asyncio.create_subprocess_exec", return_value=mock_process):
                info = await validate_prowler_installation()

                assert info["version"] == "prowler 3.5.0"
                assert info["path"] == "/usr/local/bin/prowler"
                assert info["status"] == "available"

    @pytest.mark.asyncio
    async def test_validation_execution_error(self) -> None:
        """Test validation when prowler execution fails."""
        with patch("shutil.which", return_value="/usr/bin/prowler"):
            with patch("asyncio.create_subprocess_exec", side_effect=Exception("test error")):
                with pytest.raises(ProwlerError) as exc_info:
                    await validate_prowler_installation()

                assert "Failed to validate prowler installation" in str(exc_info.value)
